# v0.8 Skills Infrastructure Implementation
## Problem Statement
Noctem needs a modular skill system to package knowledge, procedures, and (eventually) executable code. Skills are the "how" — they teach Noctem to perform specific tasks. This infrastructure enables future user-created skills and prepares for the wiki (v0.9).
## Current State
* v0.7.0 self-improvement engine complete (pattern detection, learned rules, execution logging)
* No skill system exists
* Existing infrastructure: `execution_logs`, `model_registry`, `maintenance_insights` tables
* Existing patterns: ExecutionLogger, progressive loading in slow mode
## Proposed Changes
### 1. Database Schema (db.py)
New tables:
```SQL
-- Skill registry
CREATE TABLE skills (
    id INTEGER PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,           -- 'cooking-meal-prep'
    version TEXT NOT NULL,               -- '1.0.0' (semver)
    source TEXT DEFAULT 'bundled',       -- 'bundled', 'user'
    skill_path TEXT NOT NULL,            -- Path to skill folder
    description TEXT,                    -- Short description (~100 tokens)
    triggers TEXT,                       -- JSON array of trigger patterns
    dependencies TEXT,                   -- JSON array of skill names
    requires_approval INTEGER DEFAULT 0, -- 1 if skill can execute code/web
    enabled INTEGER DEFAULT 1,
    last_used TIMESTAMP,
    use_count INTEGER DEFAULT 0,
    success_count INTEGER DEFAULT 0,
    failure_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);
-- Skill execution log (extends v0.7 logging)
CREATE TABLE skill_executions (
    id INTEGER PRIMARY KEY,
    skill_id INTEGER REFERENCES skills(id),
    trace_id TEXT,                       -- Links to execution_logs
    trigger_type TEXT,                   -- 'explicit', 'pattern_match'
    trigger_input TEXT,                  -- What triggered it
    trigger_confidence REAL,             -- 0.0-1.0 for pattern matches
    skill_version TEXT,                  -- Version at execution time
    status TEXT DEFAULT 'pending',       -- 'pending', 'approved', 'running', 'success', 'failure', 'rejected'
    approval_required INTEGER DEFAULT 0,
    approved_by TEXT,                    -- 'user', 'auto' (if not requiring approval)
    approved_at TIMESTAMP,
    output_summary TEXT,
    error_message TEXT,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
Indexes:
* `idx_skills_name` on skills(name)
* `idx_skills_enabled` on skills(enabled, source)
* `idx_skill_executions_skill` on skill_executions(skill_id, status)
* `idx_skill_executions_trace` on skill_executions(trace_id)
### 2. Data Models (models.py)
New dataclasses:
* `Skill` - Registry entry with from_row(), success_rate property
* `SkillExecution` - Execution record with from_row()
* `SkillMetadata` - Parsed SKILL.yaml content (name, version, triggers, description, dependencies, requires_approval, instructions_file)
### 3. Skill Definition Format
Directory structure:
```warp-runnable-command
skills/
├── bundled/                    # Shipped with Noctem
│   └── example-skill/
│       ├── SKILL.yaml          # Metadata
│       ├── instructions.md     # Full procedure
│       └── resources/          # Optional templates, scripts
data/
└── skills/                     # User-created
    └── my-custom-skill/
        ├── SKILL.yaml
        └── instructions.md
```
SKILL.yaml format:
```yaml
name: example-skill
version: "1.0.0"
description: "Short description for progressive disclosure (~100 tokens)"
triggers:
  - pattern: "how do I example"
    confidence_threshold: 0.8
  - pattern: "example help"
    confidence_threshold: 0.7
dependencies: []                # Other skill names
requires_approval: false        # true if can execute code/web
instructions_file: instructions.md
```
### 4. Core Modules
#### noctem/skills/**init**.py
Package init.
#### noctem/skills/registry.py
`SkillRegistry` class:
* `discover_skills()` - Scan bundled/ and data/skills/, parse SKILL.yaml, register in DB
* `get_skill(name)` - Get skill by name
* `get_all_skills(enabled_only=True)` - List skills
* `enable_skill(name)` / `disable_skill(name)`
* `get_skill_metadata(name)` - Load just SKILL.yaml (progressive disclosure)
* `get_skill_instructions(name)` - Load full instructions.md
* `update_skill_stats(name, success: bool)` - Update use/success/failure counts
#### noctem/skills/loader.py
`SkillLoader` class:
* `parse_skill_yaml(path)` -> SkillMetadata
* `validate_skill(path)` -> (valid: bool, errors: list)
* `load_instructions(skill)` -> str (full markdown)
* `get_skill_resources(skill, resource_name)` -> Path
#### noctem/skills/trigger.py
`SkillTriggerDetector` class:
* `detect_skill(input_text)` -> (skill_name, confidence) or None
* Uses fuzzy matching on trigger patterns
* Requires confidence >= threshold (high confidence pattern from v0.7)
* Falls back to None if no confident match
#### noctem/skills/executor.py
`SkillExecutor` class:
* `execute_skill(skill_name, context, approval_callback=None)` -> SkillExecution
* Creates execution record
* If requires_approval: waits for approval (or queues for Butler)
* Loads full instructions
* Logs to execution_logs via ExecutionLogger
* Updates skill stats
#### noctem/skills/service.py
`SkillService` - High-level API:
* `initialize()` - Discover skills at boot (progressive: metadata only)
* `handle_input(text, source)` -> (triggered: bool, skill_name, response)
* `run_skill(name, context)` -> response
* `list_skills()` -> List[Skill]
* `get_skill_info(name)` -> (metadata, stats)
* `create_skill(name, description, instructions)` -> Skill (user-created)
### 5. CLI Commands (cli.py)
Add skill subcommands:
* `skill list` - List installed skills with stats
* `skill info <name>` - Show skill metadata + success rate
* `skill run <name>` - Invoke a skill explicitly
* `skill enable <name>` / `skill disable <name>`
* `skill create` - Interactive skill creation wizard
* `skill validate <path>` - Validate a skill folder
### 6. Telegram Integration (telegram/handlers.py)
* `/skill` command handler
* Pattern detection in message flow (after fast classifier)
* Approval flow for skills requiring it
### 7. Web Dashboard (web/)
* `/skills` page - List skills, stats, enable/disable
* `/api/skills` - REST API for skill operations
### 8. Integration with Existing Systems
#### Fast Classifier Integration
In `fast/capture.py`:
* After classification, check SkillTriggerDetector
* If skill detected with high confidence, route to skill executor
* Otherwise, continue normal flow
#### ExecutionLogger Integration
Skill executions create traces with:
* component: 'skill'
* stage: 'trigger' -> 'load' -> 'execute' -> 'complete'
* skill_id in metadata
### 9. Testing Infrastructure
Create tests as each component is built:
* `tests/test_skill_registry.py` - Registry CRUD, discovery
* `tests/test_skill_loader.py` - YAML parsing, validation
* `tests/test_skill_trigger.py` - Pattern matching, confidence
* `tests/test_skill_executor.py` - Execution flow, logging
* `tests/test_skill_service.py` - Integration tests
* `tests/test_skill_cli.py` - CLI command tests
## Implementation Order
1. Database schema + migrations
2. Data models (Skill, SkillExecution, SkillMetadata)
3. SkillLoader (YAML parsing, validation)
4. SkillRegistry (discovery, CRUD)
5. SkillTriggerDetector (pattern matching)
6. SkillExecutor (execution flow, logging)
7. SkillService (high-level API)
8. CLI commands
9. Telegram integration
10. Web dashboard
11. Documentation updates
## Files to Create
* `noctem/skills/__init__.py`
* `noctem/skills/registry.py`
* `noctem/skills/loader.py`
* `noctem/skills/trigger.py`
* `noctem/skills/executor.py`
* `noctem/skills/service.py`
* `noctem/skills/bundled/` (empty directory for future bundled skills)
* `tests/test_skill_registry.py`
* `tests/test_skill_loader.py`
* `tests/test_skill_trigger.py`
* `tests/test_skill_executor.py`
* `tests/test_skill_service.py`
## Files to Modify
* `noctem/db.py` - Add skill tables + migrations
* `noctem/models.py` - Add Skill, SkillExecution, SkillMetadata
* `noctem/cli.py` - Add skill commands
* `noctem/fast/capture.py` - Integrate skill detection
* `noctem/telegram/handlers.py` - Add /skill command
* `docs/improvements.md` - Update v0.8 status, add post-1.0 notes
* `docs/USER_GUIDE_v0.7.0.md` → `docs/USER_GUIDE_v0.8.0.md`
* `README.md` - Update version, add skills section
## Notes
* **Git versioning consideration**: Skills can be tracked via git (skill folder is a mini-repo), but for MVP track version in SKILL.yaml + execution records. Full git integration deferred.
* **SKILL.yaml over frontmatter**: Cleaner parsing, noted for v0.9 wiki consistency.
* **High confidence triggers**: Pattern matching requires >= threshold to avoid false positives.
* **Approval field**: `requires_approval` gates dangerous skills; Butler handles approval flow.
## Research Insights (Applied)
### 1. Skill Architecture Pattern (from Claude Agent Skills, Google/AWS patterns)
**Key insight**: Skills should inject context/instructions into conversation, not just return data.
* Use "two-message pattern": brief visible notification + hidden detailed instructions
* Skills modify how the system reasons about tasks (meta-tool pattern)
* Component: 'skill' in execution traces distinguishes skill invocations
### 2. Intent Detection / Trigger Matching
**Industry standard**: 0.7-0.8 confidence threshold for routing (Oracle, AWS Lex, Dialogflow all use ~0.8 default).
**Approach**: Hybrid system combining:
* **Explicit invocation**: `/skill <name>` always routes directly (confidence=1.0)
* **Pattern matching**: Fuzzy matching with RapidFuzz (faster than FuzzyWuzzy, MIT license)
* **Fallback**: If no skill matches >= threshold, continue normal capture flow
**Implementation detail** (from research):
```python
from rapidfuzz import fuzz, process
# Use token_set_ratio for flexibility with word order
# Use WRatio for best overall matching
matches = process.extract(input_text, trigger_patterns, scorer=fuzz.WRatio, limit=3)
best_match, score = matches[0] if matches else (None, 0)
if score >= skill.confidence_threshold:  # e.g., 0.8
    return (skill_name, score / 100.0)
```
### 3. YAML Validation
**Recommended**: Use `yamale` or `cerberus` for schema validation.
* Yamale: Simple, custom validators, good for CLI tools
* Cerberus: More Pythonic, good for programmatic validation
**Schema for SKILL.yaml** (Yamale format):
```yaml
name: str()
version: str(matches='^\d+\.\d+\.\d+$')  # semver
description: str(max=500)
triggers: list(include('trigger'), min=1)
dependencies: list(str(), required=False)
requires_approval: bool()
instructions_file: str()
---
trigger:
  pattern: str()
  confidence_threshold: num(min=0.5, max=1.0)
```
### 4. Progressive Disclosure Pattern
**From Claude Skills research**: Load only ~100 tokens of metadata at boot; full instructions loaded only when skill is triggered.
* At boot: Parse all SKILL.yaml files, store metadata in DB
* On trigger: Load instructions.md only for matched skill
* Reduces memory footprint and startup time
### 5. Approval Flow Design
**Pattern from agentic AI research**: Gate dangerous actions with explicit human approval.
* Skills with `requires_approval: true` create a `skill_executions` record with `status='pending'`
* Butler surfaces approval request in next contact window (or immediately if `/summon`)
* User approves via quick-reply or explicit command
* Execution continues only after `approved_at` is set
### 6. Execution Logging Integration
**From existing v0.7 patterns**: Skill executions create traces with stages:
* `trigger` → detected skill match
* `load` → loaded full instructions
* `approve` → (if required) approval granted
* `execute` → skill running
* `complete` → success/failure
## Updated Dependencies
Add to requirements.txt:
* `rapidfuzz>=3.0.0` — Fast fuzzy string matching
* `yamale>=4.0.0` — YAML schema validation
* `pyyaml>=6.0` — YAML parsing (already present)
